(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{486:function(v,_,t){"use strict";t.r(_);var p=t(25),e=Object(p.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("当我们在设计分布式锁的时候，我们应该考虑分布式锁至少要满足的一些条件，同时考虑如何高效的设计分布式锁，这里我认为以下几点是必须要考虑的。")]),v._v(" "),t("p",[v._v("1、互斥")]),v._v(" "),t("p",[v._v("在分布式高并发的条件下，我们最需要保证，同一时刻只能有一个线程获得锁，这是最基本的一点。")]),v._v(" "),t("p",[v._v("2、防止死锁")]),v._v(" "),t("p",[v._v("在分布式高并发的条件下，比如有个线程获得锁的同时，还没有来得及去释放锁，就因为系统故障或者其它原因使它无法执行释放锁的命令,导致其它线程都无法获得锁，造成死锁。")]),v._v(" "),t("p",[v._v("所以分布式非常有必要设置锁的有效时间，确保系统出现故障后，在一定时间内能够主动去释放锁，避免造成死锁的情况。")]),v._v(" "),t("p",[v._v("3、性能")]),v._v(" "),t("p",[v._v("对于访问量大的共享资源，需要考虑减少锁等待的时间，避免导致大量线程阻塞。")]),v._v(" "),t("p",[v._v("所以在锁的设计时，需要考虑两点。")]),v._v(" "),t("p",[v._v("1、锁的颗粒度要尽量小。比如你要通过锁来减库存，那这个锁的名称你可以设置成是商品的ID,而不是任取名称。这样这个锁只对当前商品有效,锁的颗粒度小。")]),v._v(" "),t("p",[v._v("2、锁的范围尽量要小。比如只要锁2行代码就可以解决问题的，那就不要去锁10行代码了。")]),v._v(" "),t("p",[v._v("4、重入")]),v._v(" "),t("p",[v._v("我们知道ReentrantLock是可重入锁，那它的特点就是：同一个线程可以重复拿到同一个资源的锁。重入锁非常有利于资源的高效利用")])])}),[],!1,null,null,null);_.default=e.exports}}]);