(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{438:function(a,t,s){a.exports=s.p+"assets/img/023b5bb5c9ea15cefb035bc8431132f53b87b21e.85f4142f.jpg"},439:function(a,t,s){a.exports=s.p+"assets/img/1414690-20200412193117336-1589482807.d4ba0b64.png"},568:function(a,t,s){"use strict";s.r(t);var r=s(27),v=Object(r.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h2",{attrs:{id:"rdb"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rdb"}},[a._v("#")]),a._v(" RDB")]),a._v(" "),r("p",[a._v("将当前数据生成快照保存到硬盘的过程，分为手动触发和自动触发")]),a._v(" "),r("h3",{attrs:{id:"触发机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#触发机制"}},[a._v("#")]),a._v(" 触发机制")]),a._v(" "),r("h4",{attrs:{id:"手动"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#手动"}},[a._v("#")]),a._v(" 手动")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("save: 阻塞当前服务器")])]),a._v(" "),r("li",[r("p",[a._v("bgsave: fork子进程")])])]),a._v(" "),r("h4",{attrs:{id:"自动触发"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#自动触发"}},[a._v("#")]),a._v(" 自动触发")]),a._v(" "),r("div",{staticClass:"language-shell extra-class"},[r("pre",{pre:!0,attrs:{class:"language-shell"}},[r("code",[a._v("save m n "),r("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 表示m秒内存在n次修改")]),a._v("\n")])])]),r("h3",{attrs:{id:"执行流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#执行流程"}},[a._v("#")]),a._v(" 执行流程")]),a._v(" "),r("p",[r("img",{attrs:{src:s(438),alt:""}})]),a._v(" "),r("h3",{attrs:{id:"优劣"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优劣"}},[a._v("#")]),a._v(" 优劣")]),a._v(" "),r("h4",{attrs:{id:"优点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),r("ul",[r("li",[a._v("RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。")]),a._v(" "),r("li",[a._v("生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。")]),a._v(" "),r("li",[a._v("RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快")])]),a._v(" "),r("h4",{attrs:{id:"缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),r("h2",{attrs:{id:"aof"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[a._v("#")]),a._v(" AOF")]),a._v(" "),r("p",[a._v("AOF(append only file),以独立日志的方式记录每次写命令")]),a._v(" "),r("h3",{attrs:{id:"命令写入"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#命令写入"}},[a._v("#")]),a._v(" 命令写入")]),a._v(" "),r("p",[a._v("以文本协议格式写入文件，所有的写命令会追加到 "),r("code",[a._v("aof_buf")]),a._v(" 中")]),a._v(" "),r("h3",{attrs:{id:"文件同步"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#文件同步"}},[a._v("#")]),a._v(" 文件同步")]),a._v(" "),r("ul",[r("li",[a._v("appendfsync always。每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全。")]),a._v(" "),r("li",[a._v("appendfsync everysec。每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。")]),a._v(" "),r("li",[a._v("appendfsync no。从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择")])]),a._v(" "),r("h3",{attrs:{id:"重写机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#重写机制"}},[a._v("#")]),a._v(" 重写机制")]),a._v(" "),r("p",[a._v("使用重写机制来压缩文件体积，将进程内的数据转化成写命令同步到新的AOF文件里")]),a._v(" "),r("p",[r("img",{attrs:{src:s(439),alt:""}})]),a._v(" "),r("ol",[r("li",[a._v("执行重写请求")]),a._v(" "),r("li",[a._v("父进程fork子进程\n"),r("ul",[r("li",[a._v("主进程继续响应命令，所有的命令依然写入aof缓存区")]),a._v(" "),r("li",[a._v("使用aof_rewrite_buf（aof重写缓冲区）保存新的数据")])])]),a._v(" "),r("li",[a._v("子进程按照命令合并规则写入新的AOF文件")]),a._v(" "),r("li",[a._v("子进程完成AOF\n"),r("ul",[r("li",[a._v("子进程完成后发送信号给进程，父进程更新统计信息")]),a._v(" "),r("li",[a._v("父进程把AOF重写缓冲区的数据写入到新的AOF文件")])])]),a._v(" "),r("li",[a._v("新文件替代旧的文件")])]),a._v(" "),r("h3",{attrs:{id:"重启加载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#重启加载"}},[a._v("#")]),a._v(" 重启加载")]),a._v(" "),r("h2",{attrs:{id:"混合持久化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#混合持久化"}},[a._v("#")]),a._v(" 混合持久化")]),a._v(" "),r("p",[a._v("子进程先将共享的内存副本全量的以RDB方式写入aof文件，然后在将 "),r("code",[a._v("aof_rewrite_buf")]),a._v(" 重写缓冲区的增量命令以AOF方式写入到文件，\n写入完成后通知主进程更新统计信息，并将新的含有RDB格式和AOF格式的AOF文件替换旧的的AOF文件")])])}),[],!1,null,null,null);t.default=v.exports}}]);