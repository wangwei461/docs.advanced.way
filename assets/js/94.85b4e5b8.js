(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{521:function(t,a,v){"use strict";v.r(a);var _=v(25),e=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"lambda"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#lambda"}},[t._v("#")]),t._v(" Lambda")]),t._v(" "),v("h3",{attrs:{id:"lambda-表达式的定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#lambda-表达式的定义"}},[t._v("#")]),t._v(" Lambda 表达式的定义")]),t._v(" "),v("blockquote",[v("p",[t._v("包含一个参数列表和一个 "),v("code",[t._v("lambda")]),t._v(" 体，两者之间使用 "),v("code",[t._v("->")]),t._v(" 分隔")])]),t._v(" "),v("div",{staticClass:"language-java extra-class"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[t._v("args "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" expr\nargs "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" expr"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),v("ul",[v("li",[t._v("一个 Lambda 表达式可以有零个或多个参数")]),t._v(" "),v("li",[t._v("参数的类型既可以明确声明，也可以根据上下文来推断。例如："),v("code",[t._v("(int a)")]),t._v("与"),v("code",[t._v("(a)")]),t._v("效果相同")]),t._v(" "),v("li",[t._v("所有参数需包含在圆括号内，参数之间用逗号相隔。例如："),v("code",[t._v("(a, b)")]),t._v(" 或 "),v("code",[t._v("(int a, int b)")]),t._v(" 或 "),v("code",[t._v("(String a, int b, float c)")])]),t._v(" "),v("li",[t._v("空圆括号代表参数集为空。例如："),v("code",[t._v("() -> 42")])]),t._v(" "),v("li",[t._v("当只有一个参数，且其类型可推导时，圆括号（）可省略。例如："),v("code",[t._v("a -> return a*a")])]),t._v(" "),v("li",[t._v("Lambda 表达式的主体可包含零条或多条语句")]),t._v(" "),v("li",[t._v("如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致")]),t._v(" "),v("li",[t._v("如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空")])]),t._v(" "),v("h3",{attrs:{id:"functionalinterface"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#functionalinterface"}},[t._v("#")]),t._v(" @FunctionalInterface")]),t._v(" "),v("blockquote",[v("p",[t._v("指明该接口类型声明是根据 Java 语言规范定义的函数式接口")])]),t._v(" "),v("p",[t._v("函数式接口声明:")]),t._v(" "),v("div",{staticClass:"language-java extra-class"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@FunctionalInterface")]),t._v(" \n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("WorkerInterface")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("doSomeWork")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),v("p",[t._v("不能在函数式接口中定义多个方法，但可以定义默认方法、静态方法、定义java.lang.Object里的public")]),t._v(" "),v("h3",{attrs:{id:"lambda和匿名内部类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#lambda和匿名内部类"}},[t._v("#")]),t._v(" Lambda和匿名内部类")]),t._v(" "),v("ul",[v("li",[t._v("内部类创建表达式会确保创建一个拥有唯一标识的新对象")]),t._v(" "),v("li",[t._v("内部类会创建一个新的命名作用域，"),v("code",[t._v("this")]),t._v(" 和 "),v("code",[t._v("super")]),t._v(" 指向的是内部类本身的当前实例。Lambda "),v("code",[t._v("this")]),t._v(" 和 "),v("code",[t._v("super")]),t._v(" 与外围环境意义相同")])]),t._v(" "),v("h2",{attrs:{id:"java-util-function"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java-util-function"}},[t._v("#")]),t._v(" java.util.function")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("name")]),t._v(" "),v("th",[t._v("type")]),t._v(" "),v("th",[t._v("description")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("Consumer")]),t._v(" "),v("td",[t._v("Consumer< T >")]),t._v(" "),v("td",[t._v("接收T对象，不返回值")])]),t._v(" "),v("tr",[v("td",[t._v("Predicate")]),t._v(" "),v("td",[t._v("Predicate< T >")]),t._v(" "),v("td",[t._v("接收T对象并返回boolean")])]),t._v(" "),v("tr",[v("td",[t._v("Function")]),t._v(" "),v("td",[t._v("Function< T, R >")]),t._v(" "),v("td",[t._v("接收T对象，返回R对象")])]),t._v(" "),v("tr",[v("td",[t._v("Supplier")]),t._v(" "),v("td",[t._v("Supplier< T >")]),t._v(" "),v("td",[t._v("提供T对象（例如工厂），不接收值")])]),t._v(" "),v("tr",[v("td",[t._v("UnaryOperator")]),t._v(" "),v("td",[t._v("UnaryOperator")]),t._v(" "),v("td",[t._v("接收T对象，返回T对象")])]),t._v(" "),v("tr",[v("td",[t._v("BinaryOperator")]),t._v(" "),v("td",[t._v("BinaryOperator")]),t._v(" "),v("td",[t._v("接收两个T对象，返回T对象")])])])]),t._v(" "),v("h3",{attrs:{id:"consumer"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#consumer"}},[t._v("#")]),t._v(" Consumer")]),t._v(" "),v("p",[t._v("作用: 消费某个对象")]),t._v(" "),v("h3",{attrs:{id:"predicate"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#predicate"}},[t._v("#")]),t._v(" Predicate")]),t._v(" "),v("p",[t._v("作用: 判断对象是否符合某个条件\n思想: 提取条件，让条件从处理逻辑脱离出来，解耦合")]),t._v(" "),v("h3",{attrs:{id:"function"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#function"}},[t._v("#")]),t._v(" Function")]),t._v(" "),v("p",[t._v("作用: 实现一个"),v("code",[t._v("一元函数")]),t._v("，即传入一个值经过函数的计算返回另一个值。\n思想: 一元函数的思想，将转换逻辑提取出来，解耦合")]),t._v(" "),v("h3",{attrs:{id:"supplier"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#supplier"}},[t._v("#")]),t._v(" Supplier")]),t._v(" "),v("p",[t._v("作用: 创建一个对象（工厂类）\n思想: 封装工厂创建对象的逻辑")]),t._v(" "),v("h3",{attrs:{id:"方法引用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法引用"}},[t._v("#")]),t._v(" 方法引用")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("名称")]),t._v(" "),v("th",[t._v("语法")]),t._v(" "),v("th",[t._v("对应的表达式")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("静态")]),t._v(" "),v("td",[t._v("RefType::staticMethod")]),t._v(" "),v("td",[t._v("(args)->RefType.staticMethod(args)")])]),t._v(" "),v("tr",[v("td",[t._v("绑定实例")]),t._v(" "),v("td",[t._v("expr::instMethod")]),t._v(" "),v("td",[t._v("(args)->expr.instMethod(args)")])]),t._v(" "),v("tr",[v("td",[t._v("未绑定实例")]),t._v(" "),v("td",[t._v("RefType::instMethod")]),t._v(" "),v("td",[t._v("(arg0,rest)->arg0.instMethod(rest)")])]),t._v(" "),v("tr",[v("td",[t._v("构造器")]),t._v(" "),v("td",[t._v("ClsName::new")]),t._v(" "),v("td",[t._v("(args)->new ClsName(args)")])])])]),t._v(" "),v("h3",{attrs:{id:"实现原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现原理"}},[t._v("#")]),t._v(" 实现原理")]),t._v(" "),v("ol",[v("li",[t._v("在类编译时，会生成一个"),v("code",[t._v("私有静态方法")]),t._v(" + "),v("code",[t._v("一个内部类")]),t._v("；")]),t._v(" "),v("li",[t._v("在内部类中实现了函数式接口，在实现接口的方法中，会调用编译器生成的静态方法；")]),t._v(" "),v("li",[t._v("在使用lambda表达式的地方，通过传递内部类实例，来调用函数式接口方法")])])])}),[],!1,null,null,null);a.default=e.exports}}]);