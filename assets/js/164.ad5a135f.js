(window.webpackJsonp=window.webpackJsonp||[]).push([[164],{734:function(t,v,_){"use strict";_.r(v);var r=_(27),a=Object(r.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"定义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),_("p",[t._v("定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中")]),t._v(" "),_("p",[t._v("优点：")]),t._v(" "),_("ul",[_("li",[t._v("用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。")]),t._v(" "),_("li",[t._v("灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。")]),t._v(" "),_("li",[t._v("典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。")])]),t._v(" "),_("p",[t._v("缺点：")]),t._v(" "),_("ul",[_("li",[t._v("类的个数容易过多，增加复杂度")]),t._v(" "),_("li",[t._v("增加了系统的抽象性和理解难度")]),t._v(" "),_("li",[t._v("抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。")])]),t._v(" "),_("h2",{attrs:{id:"结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#结构"}},[t._v("#")]),t._v(" 结构")]),t._v(" "),_("ul",[_("li",[t._v("抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。")]),t._v(" "),_("li",[t._v("具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。")]),t._v(" "),_("li",[t._v("抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。")]),t._v(" "),_("li",[t._v("具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应")])]),t._v(" "),_("h2",{attrs:{id:"实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[t._v("#")]),t._v(" 实现")])])}),[],!1,null,null,null);v.default=a.exports}}]);