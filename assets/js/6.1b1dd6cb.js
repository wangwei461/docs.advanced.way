(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{384:function(t,a,s){t.exports=s.p+"assets/img/gc-roots.38b99b0f.jpeg"},385:function(t,a,s){t.exports=s.p+"assets/img/mark-sweep.96cd069d.png"},386:function(t,a,s){t.exports=s.p+"assets/img/copy.c09831eb.png"},387:function(t,a,s){t.exports=s.p+"assets/img/mark-compact.5c7343a9.png"},481:function(t,a,s){"use strict";s.r(a);var r=s(25),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"java-对象回收"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java-对象回收"}},[t._v("#")]),t._v(" java 对象回收")]),t._v(" "),r("h3",{attrs:{id:"gc对象搜索算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#gc对象搜索算法"}},[t._v("#")]),t._v(" GC对象搜索算法")]),t._v(" "),r("h4",{attrs:{id:"引用计数算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#引用计数算法"}},[t._v("#")]),t._v(" 引用计数算法")]),t._v(" "),r("p",[t._v("给对象一个计数器，每当这个对象被引用了，计数器值加一；引用失效，则减一。但这个对象计数值为0的时候，证明是无用对象，可以被GC程序回收掉。")]),t._v(" "),r("h4",{attrs:{id:"可达性分析算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#可达性分析算法"}},[t._v("#")]),t._v(" 可达性分析算法")]),t._v(" "),r("p",[t._v("可达性分析算法（GC roots算法），广泛应用于主流的商用语言。设置一个根节点，从图论角度来看，只要从该节点可达一个对象，证明这个对象是存活的（被引用）\n"),r("img",{attrs:{src:s(384),alt:""}}),t._v("\n通常地，GC会包含以下区域的对象：")]),t._v(" "),r("p",[t._v("虚拟机栈（栈帧中的本地变量表）中引用的对象；"),r("br"),t._v("\n方法区中类静态属性引用的对象；"),r("br"),t._v("\n方法区中常量引用的对象；"),r("br"),t._v("\n本地方法栈中JNI（即一般说的Native方法）引用的对象；")]),t._v(" "),r("h3",{attrs:{id:"垃圾回收算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[t._v("#")]),t._v(" 垃圾回收算法")]),t._v(" "),r("h4",{attrs:{id:"标记-清除算法-mark-sweep"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#标记-清除算法-mark-sweep"}},[t._v("#")]),t._v(" 标记-清除算法（Mark-Sweep）")]),t._v(" "),r("p",[t._v("标记-清除，顾名思义，先标记垃圾，再清除。它是GC最基础的算法，后续很多算法都是基于它上面去改进的。 被标记的对象，在统一GC的时候会把标记的对象清除掉\n"),r("img",{attrs:{src:s(385),alt:""}}),t._v("\n缺点:垃圾回收后会产生大量不连续的碎片空间，导致程序要申请较大的对象时常无法找到合适的内存空间，迫使再次GC。")]),t._v(" "),r("h4",{attrs:{id:"复制算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#复制算法"}},[t._v("#")]),t._v(" 复制算法")]),t._v(" "),r("p",[t._v("复制算法的存在，正是为了解决内存碎片问题。并且这个算法也是分代算法的基础。")]),t._v(" "),r("p",[t._v("将内存分为大小相等的两块，每次程序只使用其中一块，当GC发生的时候，把存活的对象复制到另外一块内存中，整齐的排列，然后清空原来的那块内存。\n"),r("img",{attrs:{src:s(386),alt:""}})]),t._v(" "),r("p",[t._v("可以看到，这种算法有点新生代转移到老年代的感觉。")]),t._v(" "),r("p",[t._v("缺点：")]),t._v(" "),r("p",[t._v("把内存可使用的空间减少了一半，造成空间的浪费。\n对象存活数量较多的时候，复制性能比较差\n这种缺点，在老年代中，对象存活率比较高的场景下是非常场景间。")]),t._v(" "),r("h4",{attrs:{id:"标记-整理算法-mark-compact"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#标记-整理算法-mark-compact"}},[t._v("#")]),t._v(" 标记-整理算法（Mark-Compact）")]),t._v(" "),r("p",[t._v("针对复制算法的两个缺点，在老年代一般会用这种标记-整理算法。\n把存活的对象移到内存的一端，然后把剩余的空间全部清空掉。\n"),r("img",{attrs:{src:s(387),alt:""}})]),t._v(" "),r("h4",{attrs:{id:"分代收集算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分代收集算法"}},[t._v("#")]),t._v(" 分代收集算法")]),t._v(" "),r("p",[t._v("分代算法并不是一个特定的算法，也没有什么新的内容。而是把内存分成多个区域，一般为新生代、老年代等。然后根据不同区域不同的特点，用不同回收算法去回收垃圾。")]),t._v(" "),r("p",[t._v("例如新生代，对象存活率低，比较适用复制算法。老年代存活率高，比较适用Mark-Compact算法。")]),t._v(" "),r("p",[t._v("目前几乎所有的商业虚拟机都是采用分代收集的。")])])}),[],!1,null,null,null);a.default=v.exports}}]);