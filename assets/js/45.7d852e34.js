(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{534:function(a,t,v){a.exports=v.p+"assets/img/1039072-20180629215028594-166842764.73fb8987.png"},702:function(a,t,v){"use strict";v.r(t);var _=v(27),r=Object(_.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h2",{attrs:{id:"分布式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式"}},[a._v("#")]),a._v(" 分布式")]),a._v(" "),_("h3",{attrs:{id:"cap"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cap"}},[a._v("#")]),a._v(" CAP")]),a._v(" "),_("ul",[_("li",[a._v("一致性：在分布式系统中的所有数据备份，在同一时刻是否同样的值。")]),a._v(" "),_("li",[a._v("可用性：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。")]),a._v(" "),_("li",[a._v("分区容忍性：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择")])]),a._v(" "),_("h3",{attrs:{id:"base理论"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#base理论"}},[a._v("#")]),a._v(" BASE理论")]),a._v(" "),_("ul",[_("li",[a._v("Basically Available（基本可用）")]),a._v(" "),_("li",[a._v("Soft state（软状态）")]),a._v(" "),_("li",[a._v("Eventually consistent（最终一致性）")])]),a._v(" "),_("h3",{attrs:{id:"分布式id"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式id"}},[a._v("#")]),a._v(" 分布式ID")]),a._v(" "),_("ul",[_("li",[a._v("唯一性：确保生成的ID是全网唯一的。")]),a._v(" "),_("li",[a._v("有序递增性：确保生成的ID是对于某个用户或者业务是按一定的数字有序递增的。")]),a._v(" "),_("li",[a._v("高可用性：确保任何时候都能正确的生成ID。")]),a._v(" "),_("li",[a._v("带时间：ID里面包含时间，一眼扫过去就知道哪天的交易")])]),a._v(" "),_("ol",[_("li",[a._v("数据库自增ID")])]),a._v(" "),_("p",[a._v("业务系统每次需要一个ID时，都需要请求数据库获取，性能低，并且如果此数据库实例下线了，那么将影响所有的业务系统")]),a._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[a._v("UUID")])]),a._v(" "),_("p",[a._v("没有排序，无法保证趋势递增。\nUUID往往是使用字符串存储，查询的效率比较低")]),a._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[_("p",[a._v("雪花算法")])]),a._v(" "),_("li",[_("p",[a._v("Redis生成ID")])])]),a._v(" "),_("p",[a._v("incr 和 increby 这样的自增原子命令")]),a._v(" "),_("h2",{attrs:{id:"高并发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#高并发"}},[a._v("#")]),a._v(" 高并发")]),a._v(" "),_("h3",{attrs:{id:"高并发下如何使用redis"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#高并发下如何使用redis"}},[a._v("#")]),a._v(" 高并发下如何使用redis")]),a._v(" "),_("p",[a._v("不是使用单机模式，主从结构（读写分离），集群模式")]),a._v(" "),_("h3",{attrs:{id:"集群、微服务、分布式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#集群、微服务、分布式"}},[a._v("#")]),a._v(" 集群、微服务、分布式")]),a._v(" "),_("ol",[_("li",[_("p",[a._v("分布式：一个业务分拆多个子业务，部署在不同的服务器上")])]),a._v(" "),_("li",[_("p",[a._v("集群：同一个业务，部署在多个服务器上")])]),a._v(" "),_("li",[_("p",[a._v("微服务 微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成")])])]),a._v(" "),_("h3",{attrs:{id:"如何设计高可用架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何设计高可用架构"}},[a._v("#")]),a._v(" 如何设计高可用架构")]),a._v(" "),_("p",[_("img",{attrs:{src:v(534),alt:""}})]),a._v(" "),_("p",[a._v("可分为前端优化、浏览器优化、应用层优化、代码层优化与存储层优化：")]),a._v(" "),_("p",[a._v("前端优化：网站业务逻辑之前的部分。")]),a._v(" "),_("p",[a._v("浏览器优化：减少 HTTP 请求数，使用浏览器缓存，启用压缩，CSS JS 位置，JS 异步，减少 Cookie 传输；CDN 加速，反向代理。")]),a._v(" "),_("p",[a._v("应用层优化：处理网站业务的服务器。使用缓存，异步，集群。")]),a._v(" "),_("p",[a._v("代码优化：合理的架构，多线程，资源复用（对象池，线程池等），良好的数据结构，JVM调优，单例，Cache 等。")]),a._v(" "),_("p",[a._v("存储优化：缓存、固态硬盘、光纤传输、优化读写、磁盘冗余、分布式存储（HDFS）、NoSQL 等")]),a._v(" "),_("p",[a._v("应用层：一般设计为无状态的，对于每次请求，使用哪一台服务器处理是没有影响的。一般使用负载均衡技术（需要解决 Session 同步问题）实现高可用。")]),a._v(" "),_("p",[a._v("服务层：负载均衡，分级管理，快速失败（超时设置），异步调用，服务降级，幂等设计等。")]),a._v(" "),_("p",[a._v("数据层：冗余备份（冷，热备[同步，异步]，温备），失效转移（确认，转移，恢复）。数据高可用方面著名的理论基础是 CAP 理论。（持久性，可用性，数据一致性[强一致，用户一致，最终一致]）")]),a._v(" "),_("h3",{attrs:{id:"分布式一致性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式一致性"}},[a._v("#")]),a._v(" 分布式一致性")]),a._v(" "),_("p",[a._v("Paxos")]),a._v(" "),_("h3",{attrs:{id:"消息队列选型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消息队列选型"}},[a._v("#")]),a._v(" 消息队列选型")]),a._v(" "),_("p",[a._v("在实际生产应用中，通常会使用kafka作为"),_("strong",[a._v("消息传输的数据管道")]),a._v("，rabbitmq作为交易数据作为"),_("strong",[a._v("数据传输管道")]),a._v("，主要的取舍因素则是是否存在丢数据的可能；\nrabbitmq 在金融场景中经常使用，具有较高的严谨性，数据丢失的可能性更小，同事具备更高的实时性；\n而kafka优势主要体现在吞吐量上，虽然可以通过策略实现数据不丢失，但从严谨性角度来讲，大不如rabbitmq；\n而且由于kafka保证每条消息最少送达一次，有较小的概率会出现数据重复发送的情况")]),a._v(" "),_("h2",{attrs:{id:"rabbitmq"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq"}},[a._v("#")]),a._v(" rabbitmq")]),a._v(" "),_("h3",{attrs:{id:"使用rabbitmq有什么好处"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用rabbitmq有什么好处"}},[a._v("#")]),a._v(" 使用RabbitMQ有什么好处？")]),a._v(" "),_("ol",[_("li",[_("p",[a._v("解耦，系统A在代码中直接调用系统B和系统C的代码，如果将来D系统接入，系统A还需要修改代码，过于麻烦！")])]),a._v(" "),_("li",[_("p",[a._v("异步，将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度")])]),a._v(" "),_("li",[_("p",[a._v("削峰，并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常")])])]),a._v(" "),_("h3",{attrs:{id:"channel、exchange-和-queue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#channel、exchange-和-queue"}},[a._v("#")]),a._v(" channel、exchange 和 queue")]),a._v(" "),_("p",[a._v("queue 具有自己的 erlang 进程；exchange 内部实现为保存 binding 关系的查找表；channel 是实际进行路由工作的实体，即负责按照 routing_key 将 message 投递给 queue")]),a._v(" "),_("h3",{attrs:{id:"vhost-是什么-起什么作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vhost-是什么-起什么作用"}},[a._v("#")]),a._v(" vhost 是什么？起什么作用？")]),a._v(" "),_("p",[a._v("可以理解为虚拟 broker。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制")]),a._v(" "),_("h3",{attrs:{id:"消息基于什么传输"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消息基于什么传输"}},[a._v("#")]),a._v(" 消息基于什么传输？")]),a._v(" "),_("p",[a._v("RabbitMQ使用信道的方式来传输数据。信道是建立在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制")]),a._v(" "),_("p",[a._v("由于TCP连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。")]),a._v(" "),_("h3",{attrs:{id:"常用的交换器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常用的交换器"}},[a._v("#")]),a._v(" 常用的交换器")]),a._v(" "),_("ul",[_("li",[a._v("Direct")])]),a._v(" "),_("p",[a._v("直连型交换机，根据消息携带的路由键将消息投递给对应队列\n大致流程，")]),a._v(" "),_("ol",[_("li",[a._v("有一个队列绑定到一个直连交换机上，同时赋予一个路由键 routing key")]),a._v(" "),_("li",[a._v("然后当一个消息携带着路由值为X，这个消息通过生产者发送给交换机时，交换机就会根据这个路由值X去寻找绑定值也是X的队列")])]),a._v(" "),_("ul",[_("li",[a._v("Fanout")])]),a._v(" "),_("p",[a._v("交换机在接收到消息后，会直接转发到绑定到它上面的所有队列")]),a._v(" "),_("ul",[_("li",[a._v("Topic")])]),a._v(" "),_("p",[a._v("使用topic交换器时，可以使用通配符，比如：“*” 匹配特定位置的任意文本， “.” 把路由键分为了几部分，“#” 匹配所有规则等")]),a._v(" "),_("p",[a._v("可以使来自不同源头的消息能够到达同一个队列")]),a._v(" "),_("h3",{attrs:{id:"队列类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#队列类型"}},[a._v("#")]),a._v(" 队列类型")]),a._v(" "),_("ol",[_("li",[a._v("Work queues(工作队列)")])]),a._v(" "),_("p",[a._v("作队列的主要思想就是将资源密集型的任务分配给多个终端处理，可以理解为轮询机制")]),a._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[a._v("Publish/Subscribe(发布/订阅)")])]),a._v(" "),_("p",[a._v("将生产者发布的消息以广播的形式发送给所有消费者")]),a._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[a._v("Routing(路由)")]),a._v(" "),_("li",[a._v("Topics(通配符)")])]),a._v(" "),_("h3",{attrs:{id:"如何解决丢数据的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何解决丢数据的问题"}},[a._v("#")]),a._v(" 如何解决丢数据的问题?")]),a._v(" "),_("ol",[_("li",[a._v("生产者丢数据")])]),a._v(" "),_("p",[a._v("RabbitMQ提供 "),_("code",[a._v("transaction")]),a._v(" 和 "),_("code",[a._v("confirm")]),a._v(" 模式来确保生产者不丢消息")]),a._v(" "),_("h4",{attrs:{id:"transaction"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#transaction"}},[a._v("#")]),a._v(" transaction")]),a._v(" "),_("p",[a._v("transaction机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())")]),a._v(" "),_("h4",{attrs:{id:"confirm"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#confirm"}},[a._v("#")]),a._v(" confirm")]),a._v(" "),_("p",[a._v("一旦channel进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个Ack给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了")]),a._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[a._v("消息队列丢数据")])]),a._v(" "),_("p",[a._v("开启持久化磁盘的配置")]),a._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[a._v("消费者丢数据")])]),a._v(" "),_("p",[a._v("①自动确认模式，消费者挂掉，待ack的消息回归到队列中。消费者抛出异常，消息会不断的被重发，直到处理成功。不会丢失消息，即便服务挂掉，没有处理完成的消息会重回队列，但是异常会让消息不断重试。")]),a._v(" "),_("p",[a._v("②手动确认模式，如果消费者来不及处理就死掉时，没有响应ack时会重复发送一条信息给其他消费者；如果监听程序处理异常了，且未对异常进行捕获，会一直重复接收消息，然后一直抛异常；如果对异常进行了捕获，但是没有在finally里ack，也会一直重复发送消息(重试机制)。")]),a._v(" "),_("p",[a._v('③不确认模式，acknowledge="none" 不使用确认机制，只要消息发送完成会立即在队列移除，无论客户端异常还是断开，只要发送完就移除，不会重发')]),a._v(" "),_("h3",{attrs:{id:"死信队列和延迟队列的使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#死信队列和延迟队列的使用"}},[a._v("#")]),a._v(" 死信队列和延迟队列的使用")])])}),[],!1,null,null,null);t.default=r.exports}}]);