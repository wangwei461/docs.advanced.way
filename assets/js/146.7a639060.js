(window.webpackJsonp=window.webpackJsonp||[]).push([[146],{710:function(a,t,r){"use strict";r.r(t);var i=r(28),v=Object(i.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h2",{attrs:{id:"rabbitmq"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq"}},[a._v("#")]),a._v(" RabbitMQ")]),a._v(" "),r("h3",{attrs:{id:"rabbitmq-的使用场景有哪些"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-的使用场景有哪些"}},[a._v("#")]),a._v(" RabbitMQ 的使用场景有哪些？")]),a._v(" "),r("ul",[r("li",[a._v("抢购活动，削峰填谷，防止系统崩塌。")]),a._v(" "),r("li",[a._v("延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。")]),a._v(" "),r("li",[a._v("解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。")])]),a._v(" "),r("h3",{attrs:{id:"rabbitmq-有哪些重要的角色"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-有哪些重要的角色"}},[a._v("#")]),a._v(" RabbitMQ 有哪些重要的角色？")]),a._v(" "),r("p",[a._v("RabbitMQ 中重要的角色有：生产者、消费者和代理：")]),a._v(" "),r("ul",[r("li",[a._v("生产者：消息的创建者，负责创建和推送数据到消息服务器；")]),a._v(" "),r("li",[a._v("消费者：消息的接收方，用于处理数据和确认消息；")]),a._v(" "),r("li",[a._v("代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。")])]),a._v(" "),r("h3",{attrs:{id:"rabbitmq-有哪些重要的组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-有哪些重要的组件"}},[a._v("#")]),a._v(" RabbitMQ 有哪些重要的组件？")]),a._v(" "),r("ul",[r("li",[a._v("ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。")]),a._v(" "),r("li",[a._v("Channel（信道）：消息推送使用的通道。")]),a._v(" "),r("li",[a._v("Exchange（交换器）：用于接受、分配消息。")]),a._v(" "),r("li",[a._v("Queue（队列）：用于存储生产者的消息。")]),a._v(" "),r("li",[a._v("RoutingKey（路由键）：用于把生成者的数据分配到交换器上。")]),a._v(" "),r("li",[a._v("BindingKey（绑定键）：用于把交换器的消息绑定到队列上。")])]),a._v(" "),r("h3",{attrs:{id:"rabbitmq-中-vhost-的作用是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-中-vhost-的作用是什么"}},[a._v("#")]),a._v(" RabbitMQ 中 vhost 的作用是什么？")]),a._v(" "),r("p",[a._v("vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。")]),a._v(" "),r("h3",{attrs:{id:"rabbitmq-的消息是怎么发送的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-的消息是怎么发送的"}},[a._v("#")]),a._v(" RabbitMQ 的消息是怎么发送的？")]),a._v(" "),r("p",[a._v("首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。")]),a._v(" "),r("h3",{attrs:{id:"rabbitmq-怎么保证消息的稳定性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-怎么保证消息的稳定性"}},[a._v("#")]),a._v(" RabbitMQ 怎么保证消息的稳定性？")]),a._v(" "),r("p",[a._v("提供了事务的功能。\n通过将 channel 设置为 confirm（确认）模式。")]),a._v(" "),r("h3",{attrs:{id:"rabbitmq-怎么避免消息丢失"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-怎么避免消息丢失"}},[a._v("#")]),a._v(" RabbitMQ 怎么避免消息丢失？")]),a._v(" "),r("p",[a._v("把消息持久化磁盘，保证服务器重启消息不丢失。\n每个集群中至少有一个物理磁盘，保证消息落入磁盘。")]),a._v(" "),r("h3",{attrs:{id:"要保证消息持久化成功的条件有哪些"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#要保证消息持久化成功的条件有哪些"}},[a._v("#")]),a._v(" 要保证消息持久化成功的条件有哪些？")]),a._v(" "),r("p",[a._v("声明队列必须设置持久化 durable 设置为 true.\n消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。\n消息已经到达持久化交换器。\n消息已经到达持久化队列。\n以上四个条件都满足才能保证消息持久化成功。")]),a._v(" "),r("h3",{attrs:{id:"rabbitmq-持久化有什么缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-持久化有什么缺点"}},[a._v("#")]),a._v(" RabbitMQ 持久化有什么缺点？")]),a._v(" "),r("p",[a._v("持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。")]),a._v(" "),r("h3",{attrs:{id:"rabbitmq-有几种广播类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-有几种广播类型"}},[a._v("#")]),a._v(" RabbitMQ 有几种广播类型？")]),a._v(" "),r("ul",[r("li",[a._v("direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。")]),a._v(" "),r("li",[a._v("headers：与 direct 类似，只是性能很差，此类型几乎用不到。")]),a._v(" "),r("li",[a._v("fanout：分发模式，把消费分发给所有订阅者。")]),a._v(" "),r("li",[a._v("topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。")])]),a._v(" "),r("h3",{attrs:{id:"rabbitmq-怎么实现延迟消息队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-怎么实现延迟消息队列"}},[a._v("#")]),a._v(" RabbitMQ 怎么实现延迟消息队列？")]),a._v(" "),r("p",[a._v("延迟队列的实现有两种方式：")]),a._v(" "),r("p",[a._v("通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；\n使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。")]),a._v(" "),r("h3",{attrs:{id:"rabbitmq-集群有什么用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-集群有什么用"}},[a._v("#")]),a._v(" RabbitMQ 集群有什么用？")]),a._v(" "),r("p",[a._v("集群主要有以下两个用途：")]),a._v(" "),r("ul",[r("li",[a._v("高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；")]),a._v(" "),r("li",[a._v("高容量：集群可以承载更多的消息量。")])]),a._v(" "),r("h3",{attrs:{id:"rabbitmq-节点的类型有哪些"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-节点的类型有哪些"}},[a._v("#")]),a._v(" RabbitMQ 节点的类型有哪些？")]),a._v(" "),r("ul",[r("li",[a._v("磁盘节点：消息会存储到磁盘。")]),a._v(" "),r("li",[a._v("内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。")])]),a._v(" "),r("h3",{attrs:{id:"rabbitmq-集群搭建需要注意哪些问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-集群搭建需要注意哪些问题"}},[a._v("#")]),a._v(" RabbitMQ 集群搭建需要注意哪些问题？")]),a._v(" "),r("ul",[r("li",[a._v("各节点之间使用“--link”连接，此属性不能忽略。")]),a._v(" "),r("li",[a._v("各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。")]),a._v(" "),r("li",[a._v("整个集群中必须包含一个磁盘节点。")])]),a._v(" "),r("h3",{attrs:{id:"rabbitmq-每个节点是其他节点的完整拷贝吗-为什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-每个节点是其他节点的完整拷贝吗-为什么"}},[a._v("#")]),a._v(" RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？")]),a._v(" "),r("p",[a._v("不是，原因有以下两个：")]),a._v(" "),r("p",[a._v("存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；\n性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。")]),a._v(" "),r("h3",{attrs:{id:"rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况"}},[a._v("#")]),a._v(" RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？")]),a._v(" "),r("p",[a._v("如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：")]),a._v(" "),r("p",[a._v("不能创建队列\n不能创建交换器\n不能创建绑定\n不能添加用户\n不能更改权限\n不能添加和删除集群节点\n唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。")]),a._v(" "),r("h3",{attrs:{id:"rabbitmq-对集群节点停止顺序有要求吗"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-对集群节点停止顺序有要求吗"}},[a._v("#")]),a._v(" RabbitMQ 对集群节点停止顺序有要求吗？")]),a._v(" "),r("p",[a._v("RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。")])])}),[],!1,null,null,null);t.default=v.exports}}]);