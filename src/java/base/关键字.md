---
title: '关键字'
---

## native

作用于方法上，Native Method就是一个java调用非java代码的接口

### 原理
当一个类第一次被使用到时，这个类的字节码会被加载到内存，并且只会回载一次。
在这个被加载的字节码的入口维持着一个该类所有方法描述符的list，这些方法描述符包含这样一些信息：方法代码存于何处，它有哪些参数，方法的描述符（public之类）等等。
如果一个方法描述符内有native，这个描述符块将有一个指向该方法的实现的指针。
这些实现在一些DLL文件内，但是它们会被操作系统加载到java程序的地址空间。当一个带有本地方法的类被加载时，其相关的DLL并未被加载，因此指向方法实现的指针并不会被设置。
当本地方法被调用之前，这些DLL才会被加载，这是通过调用java.system.loadLibrary()实现的

## transient

用transient关键字标记的成员变量不参与序列化过程

## final

### 修饰一个引用

* 修饰基本数据类型，则该引用为常量，该值无法修改；
* 修饰引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。
* 修饰类的成员变量，则必须当场赋值，否则编译会报错

### 修饰方法
这个方法将成为最终方法，无法被子类重写，可以被继承

### 修饰类
当用final修改类时，该类成为最终类，无法被继承

## abstract

1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。
2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。
5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类

### 抽象类

> 如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。

抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。
由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用

```java
public abstract class AbstractClassName{  
}

// 必须被继承
public AbstractClassName extends ClassName {
}
```

案例:
```java
abstract class Demo {
    public static void main(String[] args) {
        // 编译警告: 'Demo' is abstract; cannot be instantiated
        Demo d = new Demo();
    }
}
```

### 抽象方法

抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号

```java
public abstract class AbstractClassName{
    public abstract void method();
}
```

* 如果一个类包含抽象方法，那么该类必须是抽象类。
* 任何子类必须重写父类的抽象方法，或者声明自身为抽象类